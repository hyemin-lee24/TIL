- ## 🔐 `synchronized` 실무 사용 시 자주 겪는 문제와 대안

  > Java에서 `synchronized`는 가장 단순한 동기화 수단이지만, **실무에서는 오히려 문제의 원인이 되는 경우가 많다**.

  ------

  ### 🔍 왜 문제가 되는가?

  `synchronized`는 문법적으로 단순하지만, 다음과 같은 **실질적인 리스크**를 수반한다:

  - **성능 병목** (불필요한 락 경쟁)
  - **디버깅 난이도** 상승 (JVM 모니터 기반)
  - **설계 유연성 제한** (고립된 책임 부여 어려움)

  ------

  ### ⚠️ 실전에서 마주친 주요 이슈

  #### 1. ❗ 락 범위 과도 → 성능 병목

  ```java
  public synchronized void process() {
      // DB I/O, 계산, 로그 출력까지 모두 락 안에서 처리
  }
  ```

  - 문제: **불필요한 락 범위로 인해 스레드 경합 심화**
  - 해결: **핵심 공유 자원 처리만 최소 블록에 분리**

  ```java
  public void process() {
      compute(); // 락 없이 가능
  
      synchronized (lock) {
          updateSharedState();
      }
  }
  ```

  #### 2. ❗ 클래스 수준 락으로 병렬성 저하

  ```java
  public static synchronized void logGlobal() {
      // 모든 스레드가 대기
  }
  ```

  - 문제: `static synchronized`는 클래스 단위 락 → **인스턴스 간 병렬 처리 불가**
  - 해결: **인스턴스 기반 락**, 혹은 **세분화된 컨텍스트 락 분리**

  #### 3. ❗ 잘못된 락 대상 → 동기화 무력화

  ```java
  synchronized (new Object()) {
      // 매번 새로운 객체에 락
  }
  ```

  - 문제: 매번 새로운 객체 생성 → **락 의미 없음**
  - 해결: **공유 객체(lock)** 에 락을 걸도록 명시적으로 관리

  #### 4. ❗ 교착 상태(Deadlock)

  ```java
  // Thread A
  synchronized (lock1) {
      synchronized (lock2) { }
  }
  
  // Thread B
  synchronized (lock2) {
      synchronized (lock1) { }
  }
  ```

  - 문제: 락 순서 불일치 → **상호 대기 상황**
  - 해결:
    - **락 획득 순서 고정**
    - 혹은 `ReentrantLock.tryLock()` 등으로 회피 전략 마련

  #### 5. ❗ 디버깅 어려움

  - 문제: JVM 내부 모니터 락 사용 → **스레드 덤프 없이는 상태 파악 불가**
  - 해결: `jstack`, `VisualVM` 활용 또는 **명시적 락 도구 (`ReentrantLock`) 사용**

  ------

  ### 🔁 대체 방안 및 권장 도구

  | 도구                                    | 장점                                                         | 단점                              |
  | --------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
  | `ReentrantLock`                         | `tryLock`, `lockInterruptibly`, 조건 변수 등 **세밀한 제어 가능** | 코드 복잡도 증가                  |
  | `StampedLock`                           | 읽기/쓰기 분리로 **낙관적 락 지원, 성능 향상**               | 사용법 복잡, 실수 시 버그 위험    |
  | `volatile`                              | **가시성 보장** (특정 플래그 등에 유용)                      | 원자성 보장 X                     |
  | `ConcurrentHashMap`, `AtomicInteger` 등 | 고성능, 락리스(lok-free) 구현                                | 특정 목적에만 적합, 일반화 어려움 |

  

  ------

  ### 💬 실무에서 얻은 교훈

  - `synchronized`는 **간단한 단일 스레드 보호**에는 유용하지만,
    - 스케일 확장
    - 코드 유지보수
    - 다중 자원 처리 와 같은 상황에선 **부적합하거나 위험해질 수 있음**.
  - 복잡한 동기화 문제는 **코드 차원이 아닌 설계 차원에서 해결하는 것이 더 지속 가능함**.
    - **공유 상태 최소화**
    - **불변 객체 설계**
    - **책임 분리** 구조 도입

  ------

  ### ✅ 요약

  - `synchronized`는 진입장벽은 낮지만, **생산성과 안정성 모두를 해칠 수 있는 양날의 검**
  - 실무에서는 반드시 다음을 명확히 해야 함:
    - **락 범위는 작게**
    - **락 대상은 일관되게**
    - **락 순서는 고정**
  - 가능한 경우, **명시적 동기화 도구나 구조적 리팩터링**으로 대체하는 것이 더 안전하고 확장 가능함